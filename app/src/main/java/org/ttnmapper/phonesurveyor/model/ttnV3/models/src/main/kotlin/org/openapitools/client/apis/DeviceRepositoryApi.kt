/**
 * The Things Stack for LoRaWAN v3 API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.RuntimeError
import org.openapitools.client.models.V3EndDeviceBrand
import org.openapitools.client.models.V3EndDeviceModel
import org.openapitools.client.models.V3EndDeviceTemplate
import org.openapitools.client.models.V3ListEndDeviceBrandsResponse
import org.openapitools.client.models.V3ListEndDeviceModelsResponse
import org.openapitools.client.models.V3MessagePayloadDecoder
import org.openapitools.client.models.V3MessagePayloadEncoder

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiInfrastructureResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DeviceRepositoryApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId Brand identifier, as defined in the Device Repository. 
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3EndDeviceBrand
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetBrand(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3EndDeviceBrand {
        val localVarResponse = deviceRepositoryGetBrandWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3EndDeviceBrand
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId Brand identifier, as defined in the Device Repository. 
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3EndDeviceBrand?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetBrandWithHttpInfo(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3EndDeviceBrand?> {
        val localVariableConfig = deviceRepositoryGetBrandRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3EndDeviceBrand>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryGetBrand
    *
    * @param applicationIdsApplicationId  
    * @param brandId Brand identifier, as defined in the Device Repository. 
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryGetBrandRequestConfig(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands/{brand_id}".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"brand_id"+"}", "$brandId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3MessagePayloadDecoder
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetDownlinkDecoder(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3MessagePayloadDecoder {
        val localVarResponse = deviceRepositoryGetDownlinkDecoderWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3MessagePayloadDecoder
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3MessagePayloadDecoder?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetDownlinkDecoderWithHttpInfo(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3MessagePayloadDecoder?> {
        val localVariableConfig = deviceRepositoryGetDownlinkDecoderRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3MessagePayloadDecoder>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryGetDownlinkDecoder
    *
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryGetDownlinkDecoderRequestConfig(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (versionIdsHardwareVersion != null) {
                    put("version_ids.hardware_version", listOf(versionIdsHardwareVersion.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands/{version_ids.brand_id}/models/{version_ids.model_id}/{version_ids.firmware_version}/{version_ids.band_id}/formatters/downlink/decoder".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"version_ids.brand_id"+"}", "$versionIdsBrandId").replace("{"+"version_ids.model_id"+"}", "$versionIdsModelId").replace("{"+"version_ids.firmware_version"+"}", "$versionIdsFirmwareVersion").replace("{"+"version_ids.band_id"+"}", "$versionIdsBandId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3MessagePayloadEncoder
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetDownlinkEncoder(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3MessagePayloadEncoder {
        val localVarResponse = deviceRepositoryGetDownlinkEncoderWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3MessagePayloadEncoder
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3MessagePayloadEncoder?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetDownlinkEncoderWithHttpInfo(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3MessagePayloadEncoder?> {
        val localVariableConfig = deviceRepositoryGetDownlinkEncoderRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3MessagePayloadEncoder>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryGetDownlinkEncoder
    *
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryGetDownlinkEncoderRequestConfig(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (versionIdsHardwareVersion != null) {
                    put("version_ids.hardware_version", listOf(versionIdsHardwareVersion.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands/{version_ids.brand_id}/models/{version_ids.model_id}/{version_ids.firmware_version}/{version_ids.band_id}/formatters/downlink/encoder".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"version_ids.brand_id"+"}", "$versionIdsBrandId").replace("{"+"version_ids.model_id"+"}", "$versionIdsModelId").replace("{"+"version_ids.firmware_version"+"}", "$versionIdsFirmwareVersion").replace("{"+"version_ids.band_id"+"}", "$versionIdsBandId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId Brand identifier, as defined in the Device Repository. 
    * @param modelId Model identifier, as defined in the Device Repository. 
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3EndDeviceModel
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetModel(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, modelId: kotlin.String, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3EndDeviceModel {
        val localVarResponse = deviceRepositoryGetModelWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, modelId = modelId, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3EndDeviceModel
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId Brand identifier, as defined in the Device Repository. 
    * @param modelId Model identifier, as defined in the Device Repository. 
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3EndDeviceModel?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetModelWithHttpInfo(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, modelId: kotlin.String, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3EndDeviceModel?> {
        val localVariableConfig = deviceRepositoryGetModelRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, modelId = modelId, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3EndDeviceModel>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryGetModel
    *
    * @param applicationIdsApplicationId  
    * @param brandId Brand identifier, as defined in the Device Repository. 
    * @param modelId Model identifier, as defined in the Device Repository. 
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryGetModelRequestConfig(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, modelId: kotlin.String, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands/{brand_id}/models/{model_id}".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"brand_id"+"}", "$brandId").replace("{"+"model_id"+"}", "$modelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @return V3EndDeviceTemplate
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetTemplate(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?) : V3EndDeviceTemplate {
        val localVarResponse = deviceRepositoryGetTemplateWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3EndDeviceTemplate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @return ApiInfrastructureResponse<V3EndDeviceTemplate?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetTemplateWithHttpInfo(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?) : ApiInfrastructureResponse<V3EndDeviceTemplate?> {
        val localVariableConfig = deviceRepositoryGetTemplateRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion)

        return request<Unit, V3EndDeviceTemplate>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryGetTemplate
    *
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryGetTemplateRequestConfig(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (versionIdsHardwareVersion != null) {
                    put("version_ids.hardware_version", listOf(versionIdsHardwareVersion.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands/{version_ids.brand_id}/models/{version_ids.model_id}/{version_ids.firmware_version}/{version_ids.band_id}/template".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"version_ids.brand_id"+"}", "$versionIdsBrandId").replace("{"+"version_ids.model_id"+"}", "$versionIdsModelId").replace("{"+"version_ids.firmware_version"+"}", "$versionIdsFirmwareVersion").replace("{"+"version_ids.band_id"+"}", "$versionIdsBandId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3MessagePayloadDecoder
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetUplinkDecoder(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3MessagePayloadDecoder {
        val localVarResponse = deviceRepositoryGetUplinkDecoderWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3MessagePayloadDecoder
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3MessagePayloadDecoder?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryGetUplinkDecoderWithHttpInfo(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3MessagePayloadDecoder?> {
        val localVariableConfig = deviceRepositoryGetUplinkDecoderRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, versionIdsBrandId = versionIdsBrandId, versionIdsModelId = versionIdsModelId, versionIdsFirmwareVersion = versionIdsFirmwareVersion, versionIdsBandId = versionIdsBandId, versionIdsHardwareVersion = versionIdsHardwareVersion, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3MessagePayloadDecoder>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryGetUplinkDecoder
    *
    * @param applicationIdsApplicationId  
    * @param versionIdsBrandId  
    * @param versionIdsModelId  
    * @param versionIdsFirmwareVersion  
    * @param versionIdsBandId  
    * @param versionIdsHardwareVersion  (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryGetUplinkDecoderRequestConfig(applicationIdsApplicationId: kotlin.String, versionIdsBrandId: kotlin.String, versionIdsModelId: kotlin.String, versionIdsFirmwareVersion: kotlin.String, versionIdsBandId: kotlin.String, versionIdsHardwareVersion: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (versionIdsHardwareVersion != null) {
                    put("version_ids.hardware_version", listOf(versionIdsHardwareVersion.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands/{version_ids.brand_id}/models/{version_ids.model_id}/{version_ids.firmware_version}/{version_ids.band_id}/formatters/uplink/decoder".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"version_ids.brand_id"+"}", "$versionIdsBrandId").replace("{"+"version_ids.model_id"+"}", "$versionIdsModelId").replace("{"+"version_ids.firmware_version"+"}", "$versionIdsFirmwareVersion").replace("{"+"version_ids.band_id"+"}", "$versionIdsBandId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order (for pagination). (optional)
    * @param search Search for brands matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3ListEndDeviceBrandsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryListBrands(applicationIdsApplicationId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3ListEndDeviceBrandsResponse {
        val localVarResponse = deviceRepositoryListBrandsWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, limit = limit, page = page, orderBy = orderBy, search = search, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ListEndDeviceBrandsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order (for pagination). (optional)
    * @param search Search for brands matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3ListEndDeviceBrandsResponse?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryListBrandsWithHttpInfo(applicationIdsApplicationId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3ListEndDeviceBrandsResponse?> {
        val localVariableConfig = deviceRepositoryListBrandsRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, limit = limit, page = page, orderBy = orderBy, search = search, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3ListEndDeviceBrandsResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryListBrands
    *
    * @param applicationIdsApplicationId  
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order (for pagination). (optional)
    * @param search Search for brands matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryListBrandsRequestConfig(applicationIdsApplicationId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId List end devices from a specific brand. 
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order end devices. (optional)
    * @param search List end devices matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3ListEndDeviceModelsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryListModels(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3ListEndDeviceModelsResponse {
        val localVarResponse = deviceRepositoryListModelsWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, limit = limit, page = page, orderBy = orderBy, search = search, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ListEndDeviceModelsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId List end devices from a specific brand. 
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order end devices. (optional)
    * @param search List end devices matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3ListEndDeviceModelsResponse?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryListModelsWithHttpInfo(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3ListEndDeviceModelsResponse?> {
        val localVariableConfig = deviceRepositoryListModelsRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, limit = limit, page = page, orderBy = orderBy, search = search, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3ListEndDeviceModelsResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryListModels
    *
    * @param applicationIdsApplicationId  
    * @param brandId List end devices from a specific brand. 
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order end devices. (optional)
    * @param search List end devices matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryListModelsRequestConfig(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/brands/{brand_id}/models".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"brand_id"+"}", "$brandId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId List end devices from a specific brand. (optional)
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order end devices. (optional)
    * @param search List end devices matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3ListEndDeviceModelsResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryListModels2(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String?, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3ListEndDeviceModelsResponse {
        val localVarResponse = deviceRepositoryListModels2WithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, limit = limit, page = page, orderBy = orderBy, search = search, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ListEndDeviceModelsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * 
    * 
    * @param applicationIdsApplicationId  
    * @param brandId List end devices from a specific brand. (optional)
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order end devices. (optional)
    * @param search List end devices matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3ListEndDeviceModelsResponse?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceRepositoryListModels2WithHttpInfo(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String?, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3ListEndDeviceModelsResponse?> {
        val localVariableConfig = deviceRepositoryListModels2RequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, brandId = brandId, limit = limit, page = page, orderBy = orderBy, search = search, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3ListEndDeviceModelsResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deviceRepositoryListModels2
    *
    * @param applicationIdsApplicationId  
    * @param brandId List end devices from a specific brand. (optional)
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param orderBy Order end devices. (optional)
    * @param search List end devices matching a query string. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun deviceRepositoryListModels2RequestConfig(applicationIdsApplicationId: kotlin.String, brandId: kotlin.String?, limit: kotlin.Long?, page: kotlin.Long?, orderBy: kotlin.String?, search: kotlin.String?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (brandId != null) {
                    put("brand_id", listOf(brandId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dr/applications/{application_ids.application_id}/models".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
