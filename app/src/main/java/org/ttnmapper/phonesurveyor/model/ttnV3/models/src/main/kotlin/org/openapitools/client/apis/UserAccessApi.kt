/**
 * The Things Stack for LoRaWAN v3 API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.RuntimeError
import org.openapitools.client.models.V3APIKey
import org.openapitools.client.models.V3APIKeys
import org.openapitools.client.models.V3CreateLoginTokenResponse
import org.openapitools.client.models.V3CreateUserAPIKeyRequest
import org.openapitools.client.models.V3Rights
import org.openapitools.client.models.V3UpdateUserAPIKeyRequest

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiInfrastructureResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class UserAccessApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
    * Create an API key scoped to this user. User API keys can give access to the user itself, as well as any organization, application, gateway and OAuth client this user is a collaborator of.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param body  
    * @return V3APIKey
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessCreateAPIKey(userIdsUserId: kotlin.String, body: V3CreateUserAPIKeyRequest) : V3APIKey {
        val localVarResponse = userAccessCreateAPIKeyWithHttpInfo(userIdsUserId = userIdsUserId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3APIKey
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create an API key scoped to this user. User API keys can give access to the user itself, as well as any organization, application, gateway and OAuth client this user is a collaborator of.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param body  
    * @return ApiInfrastructureResponse<V3APIKey?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessCreateAPIKeyWithHttpInfo(userIdsUserId: kotlin.String, body: V3CreateUserAPIKeyRequest) : ApiInfrastructureResponse<V3APIKey?> {
        val localVariableConfig = userAccessCreateAPIKeyRequestConfig(userIdsUserId = userIdsUserId, body = body)

        return request<V3CreateUserAPIKeyRequest, V3APIKey>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation userAccessCreateAPIKey
    *
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param body  
    * @return RequestConfig
    */
    fun userAccessCreateAPIKeyRequestConfig(userIdsUserId: kotlin.String, body: V3CreateUserAPIKeyRequest) : RequestConfig<V3CreateUserAPIKeyRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/{user_ids.user_id}/api-keys".replace("{"+"user_ids.user_id"+"}", "$userIdsUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a login token that can be used for a one-time login as a user.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @return V3CreateLoginTokenResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessCreateLoginToken(userIdsUserId: kotlin.String) : V3CreateLoginTokenResponse {
        val localVarResponse = userAccessCreateLoginTokenWithHttpInfo(userIdsUserId = userIdsUserId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3CreateLoginTokenResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Create a login token that can be used for a one-time login as a user.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @return ApiInfrastructureResponse<V3CreateLoginTokenResponse?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessCreateLoginTokenWithHttpInfo(userIdsUserId: kotlin.String) : ApiInfrastructureResponse<V3CreateLoginTokenResponse?> {
        val localVariableConfig = userAccessCreateLoginTokenRequestConfig(userIdsUserId = userIdsUserId)

        return request<Unit, V3CreateLoginTokenResponse>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation userAccessCreateLoginToken
    *
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @return RequestConfig
    */
    fun userAccessCreateLoginTokenRequestConfig(userIdsUserId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/{user_ids.user_id}/login-tokens".replace("{"+"user_ids.user_id"+"}", "$userIdsUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a single API key of this user.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param keyId Unique public identifier for the API key. 
    * @param userIdsEmail Secondary identifier, which can only be used in specific requests. (optional)
    * @return V3APIKey
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessGetAPIKey(userIdsUserId: kotlin.String, keyId: kotlin.String, userIdsEmail: kotlin.String?) : V3APIKey {
        val localVarResponse = userAccessGetAPIKeyWithHttpInfo(userIdsUserId = userIdsUserId, keyId = keyId, userIdsEmail = userIdsEmail)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3APIKey
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get a single API key of this user.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param keyId Unique public identifier for the API key. 
    * @param userIdsEmail Secondary identifier, which can only be used in specific requests. (optional)
    * @return ApiInfrastructureResponse<V3APIKey?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessGetAPIKeyWithHttpInfo(userIdsUserId: kotlin.String, keyId: kotlin.String, userIdsEmail: kotlin.String?) : ApiInfrastructureResponse<V3APIKey?> {
        val localVariableConfig = userAccessGetAPIKeyRequestConfig(userIdsUserId = userIdsUserId, keyId = keyId, userIdsEmail = userIdsEmail)

        return request<Unit, V3APIKey>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation userAccessGetAPIKey
    *
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param keyId Unique public identifier for the API key. 
    * @param userIdsEmail Secondary identifier, which can only be used in specific requests. (optional)
    * @return RequestConfig
    */
    fun userAccessGetAPIKeyRequestConfig(userIdsUserId: kotlin.String, keyId: kotlin.String, userIdsEmail: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (userIdsEmail != null) {
                    put("user_ids.email", listOf(userIdsEmail.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{user_ids.user_id}/api-keys/{key_id}".replace("{"+"user_ids.user_id"+"}", "$userIdsUserId").replace("{"+"key_id"+"}", "$keyId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List the API keys for this user.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param userIdsEmail Secondary identifier, which can only be used in specific requests. (optional)
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @return V3APIKeys
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessListAPIKeys(userIdsUserId: kotlin.String, userIdsEmail: kotlin.String?, limit: kotlin.Long?, page: kotlin.Long?) : V3APIKeys {
        val localVarResponse = userAccessListAPIKeysWithHttpInfo(userIdsUserId = userIdsUserId, userIdsEmail = userIdsEmail, limit = limit, page = page)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3APIKeys
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * List the API keys for this user.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param userIdsEmail Secondary identifier, which can only be used in specific requests. (optional)
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @return ApiInfrastructureResponse<V3APIKeys?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessListAPIKeysWithHttpInfo(userIdsUserId: kotlin.String, userIdsEmail: kotlin.String?, limit: kotlin.Long?, page: kotlin.Long?) : ApiInfrastructureResponse<V3APIKeys?> {
        val localVariableConfig = userAccessListAPIKeysRequestConfig(userIdsUserId = userIdsUserId, userIdsEmail = userIdsEmail, limit = limit, page = page)

        return request<Unit, V3APIKeys>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation userAccessListAPIKeys
    *
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param userIdsEmail Secondary identifier, which can only be used in specific requests. (optional)
    * @param limit Limit the number of results per page. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @return RequestConfig
    */
    fun userAccessListAPIKeysRequestConfig(userIdsUserId: kotlin.String, userIdsEmail: kotlin.String?, limit: kotlin.Long?, page: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (userIdsEmail != null) {
                    put("user_ids.email", listOf(userIdsEmail.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{user_ids.user_id}/api-keys".replace("{"+"user_ids.user_id"+"}", "$userIdsUserId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List the rights the caller has on this user.
    * 
    * @param userId This ID shares namespace with organization IDs. 
    * @param email Secondary identifier, which can only be used in specific requests. (optional)
    * @return V3Rights
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessListRights(userId: kotlin.String, email: kotlin.String?) : V3Rights {
        val localVarResponse = userAccessListRightsWithHttpInfo(userId = userId, email = email)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3Rights
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * List the rights the caller has on this user.
    * 
    * @param userId This ID shares namespace with organization IDs. 
    * @param email Secondary identifier, which can only be used in specific requests. (optional)
    * @return ApiInfrastructureResponse<V3Rights?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessListRightsWithHttpInfo(userId: kotlin.String, email: kotlin.String?) : ApiInfrastructureResponse<V3Rights?> {
        val localVariableConfig = userAccessListRightsRequestConfig(userId = userId, email = email)

        return request<Unit, V3Rights>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation userAccessListRights
    *
    * @param userId This ID shares namespace with organization IDs. 
    * @param email Secondary identifier, which can only be used in specific requests. (optional)
    * @return RequestConfig
    */
    fun userAccessListRightsRequestConfig(userId: kotlin.String, email: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{user_id}/rights".replace("{"+"user_id"+"}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update the rights of an API key of the user. This method can also be used to delete the API key, by giving it no rights. The caller is required to have all assigned or/and removed rights.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param apiKeyId Immutable and unique public identifier for the API key. Generated by the Access Server. 
    * @param body  
    * @return V3APIKey
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessUpdateAPIKey(userIdsUserId: kotlin.String, apiKeyId: kotlin.String, body: V3UpdateUserAPIKeyRequest) : V3APIKey {
        val localVarResponse = userAccessUpdateAPIKeyWithHttpInfo(userIdsUserId = userIdsUserId, apiKeyId = apiKeyId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3APIKey
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Update the rights of an API key of the user. This method can also be used to delete the API key, by giving it no rights. The caller is required to have all assigned or/and removed rights.
    * 
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param apiKeyId Immutable and unique public identifier for the API key. Generated by the Access Server. 
    * @param body  
    * @return ApiInfrastructureResponse<V3APIKey?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccessUpdateAPIKeyWithHttpInfo(userIdsUserId: kotlin.String, apiKeyId: kotlin.String, body: V3UpdateUserAPIKeyRequest) : ApiInfrastructureResponse<V3APIKey?> {
        val localVariableConfig = userAccessUpdateAPIKeyRequestConfig(userIdsUserId = userIdsUserId, apiKeyId = apiKeyId, body = body)

        return request<V3UpdateUserAPIKeyRequest, V3APIKey>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation userAccessUpdateAPIKey
    *
    * @param userIdsUserId This ID shares namespace with organization IDs. 
    * @param apiKeyId Immutable and unique public identifier for the API key. Generated by the Access Server. 
    * @param body  
    * @return RequestConfig
    */
    fun userAccessUpdateAPIKeyRequestConfig(userIdsUserId: kotlin.String, apiKeyId: kotlin.String, body: V3UpdateUserAPIKeyRequest) : RequestConfig<V3UpdateUserAPIKeyRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/users/{user_ids.user_id}/api-keys/{api_key.id}".replace("{"+"user_ids.user_id"+"}", "$userIdsUserId").replace("{"+"api_key.id"+"}", "$apiKeyId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
