/**
 * The Things Stack for LoRaWAN v3 API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import org.openapitools.client.models.RuntimeError
import org.openapitools.client.models.V3ApplicationPackageAssociation
import org.openapitools.client.models.V3ApplicationPackageAssociations
import org.openapitools.client.models.V3ApplicationPackageDefaultAssociation
import org.openapitools.client.models.V3ApplicationPackageDefaultAssociations
import org.openapitools.client.models.V3ApplicationPackages
import org.openapitools.client.models.V3SetApplicationPackageAssociationRequest
import org.openapitools.client.models.V3SetApplicationPackageDefaultAssociationRequest

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiInfrastructureResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class ApplicationPackageRegistryApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
    * DeleteAssociation removes the association on the FPort of the end device.
    * 
    * @param endDeviceIdsApplicationIdsApplicationId  
    * @param endDeviceIdsDeviceId  
    * @param fPort  
    * @param endDeviceIdsDevEui The LoRaWAN DevEUI. (optional)
    * @param endDeviceIdsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param endDeviceIdsDevAddr The LoRaWAN DevAddr. (optional)
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryDeleteAssociation(endDeviceIdsApplicationIdsApplicationId: kotlin.String, endDeviceIdsDeviceId: kotlin.String, fPort: kotlin.Long, endDeviceIdsDevEui: kotlin.ByteArray?, endDeviceIdsJoinEui: kotlin.ByteArray?, endDeviceIdsDevAddr: kotlin.ByteArray?) : kotlin.Any {
        val localVarResponse = applicationPackageRegistryDeleteAssociationWithHttpInfo(endDeviceIdsApplicationIdsApplicationId = endDeviceIdsApplicationIdsApplicationId, endDeviceIdsDeviceId = endDeviceIdsDeviceId, fPort = fPort, endDeviceIdsDevEui = endDeviceIdsDevEui, endDeviceIdsJoinEui = endDeviceIdsJoinEui, endDeviceIdsDevAddr = endDeviceIdsDevAddr)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * DeleteAssociation removes the association on the FPort of the end device.
    * 
    * @param endDeviceIdsApplicationIdsApplicationId  
    * @param endDeviceIdsDeviceId  
    * @param fPort  
    * @param endDeviceIdsDevEui The LoRaWAN DevEUI. (optional)
    * @param endDeviceIdsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param endDeviceIdsDevAddr The LoRaWAN DevAddr. (optional)
    * @return ApiInfrastructureResponse<kotlin.Any?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryDeleteAssociationWithHttpInfo(endDeviceIdsApplicationIdsApplicationId: kotlin.String, endDeviceIdsDeviceId: kotlin.String, fPort: kotlin.Long, endDeviceIdsDevEui: kotlin.ByteArray?, endDeviceIdsJoinEui: kotlin.ByteArray?, endDeviceIdsDevAddr: kotlin.ByteArray?) : ApiInfrastructureResponse<kotlin.Any?> {
        val localVariableConfig = applicationPackageRegistryDeleteAssociationRequestConfig(endDeviceIdsApplicationIdsApplicationId = endDeviceIdsApplicationIdsApplicationId, endDeviceIdsDeviceId = endDeviceIdsDeviceId, fPort = fPort, endDeviceIdsDevEui = endDeviceIdsDevEui, endDeviceIdsJoinEui = endDeviceIdsJoinEui, endDeviceIdsDevAddr = endDeviceIdsDevAddr)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistryDeleteAssociation
    *
    * @param endDeviceIdsApplicationIdsApplicationId  
    * @param endDeviceIdsDeviceId  
    * @param fPort  
    * @param endDeviceIdsDevEui The LoRaWAN DevEUI. (optional)
    * @param endDeviceIdsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param endDeviceIdsDevAddr The LoRaWAN DevAddr. (optional)
    * @return RequestConfig
    */
    fun applicationPackageRegistryDeleteAssociationRequestConfig(endDeviceIdsApplicationIdsApplicationId: kotlin.String, endDeviceIdsDeviceId: kotlin.String, fPort: kotlin.Long, endDeviceIdsDevEui: kotlin.ByteArray?, endDeviceIdsJoinEui: kotlin.ByteArray?, endDeviceIdsDevAddr: kotlin.ByteArray?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (endDeviceIdsDevEui != null) {
                    put("end_device_ids.dev_eui", listOf(endDeviceIdsDevEui.toString()))
                }
                if (endDeviceIdsJoinEui != null) {
                    put("end_device_ids.join_eui", listOf(endDeviceIdsJoinEui.toString()))
                }
                if (endDeviceIdsDevAddr != null) {
                    put("end_device_ids.dev_addr", listOf(endDeviceIdsDevAddr.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/as/applications/{end_device_ids.application_ids.application_id}/devices/{end_device_ids.device_id}/packages/associations/{f_port}".replace("{"+"end_device_ids.application_ids.application_id"+"}", "$endDeviceIdsApplicationIdsApplicationId").replace("{"+"end_device_ids.device_id"+"}", "$endDeviceIdsDeviceId").replace("{"+"f_port"+"}", "$fPort"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * DeleteDefaultAssociation removes the default association on the FPort of the application.
    * 
    * @param applicationIdsApplicationId  
    * @param fPort  
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryDeleteDefaultAssociation(applicationIdsApplicationId: kotlin.String, fPort: kotlin.Long) : kotlin.Any {
        val localVarResponse = applicationPackageRegistryDeleteDefaultAssociationWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, fPort = fPort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * DeleteDefaultAssociation removes the default association on the FPort of the application.
    * 
    * @param applicationIdsApplicationId  
    * @param fPort  
    * @return ApiInfrastructureResponse<kotlin.Any?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryDeleteDefaultAssociationWithHttpInfo(applicationIdsApplicationId: kotlin.String, fPort: kotlin.Long) : ApiInfrastructureResponse<kotlin.Any?> {
        val localVariableConfig = applicationPackageRegistryDeleteDefaultAssociationRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, fPort = fPort)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistryDeleteDefaultAssociation
    *
    * @param applicationIdsApplicationId  
    * @param fPort  
    * @return RequestConfig
    */
    fun applicationPackageRegistryDeleteDefaultAssociationRequestConfig(applicationIdsApplicationId: kotlin.String, fPort: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/as/applications/{application_ids.application_id}/packages/associations/{f_port}".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"f_port"+"}", "$fPort"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * GetAssociation returns the association registered on the FPort of the end device.
    * 
    * @param idsEndDeviceIdsApplicationIdsApplicationId  
    * @param idsEndDeviceIdsDeviceId  
    * @param idsFPort  
    * @param idsEndDeviceIdsDevEui The LoRaWAN DevEUI. (optional)
    * @param idsEndDeviceIdsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param idsEndDeviceIdsDevAddr The LoRaWAN DevAddr. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3ApplicationPackageAssociation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryGetAssociation(idsEndDeviceIdsApplicationIdsApplicationId: kotlin.String, idsEndDeviceIdsDeviceId: kotlin.String, idsFPort: kotlin.Long, idsEndDeviceIdsDevEui: kotlin.ByteArray?, idsEndDeviceIdsJoinEui: kotlin.ByteArray?, idsEndDeviceIdsDevAddr: kotlin.ByteArray?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3ApplicationPackageAssociation {
        val localVarResponse = applicationPackageRegistryGetAssociationWithHttpInfo(idsEndDeviceIdsApplicationIdsApplicationId = idsEndDeviceIdsApplicationIdsApplicationId, idsEndDeviceIdsDeviceId = idsEndDeviceIdsDeviceId, idsFPort = idsFPort, idsEndDeviceIdsDevEui = idsEndDeviceIdsDevEui, idsEndDeviceIdsJoinEui = idsEndDeviceIdsJoinEui, idsEndDeviceIdsDevAddr = idsEndDeviceIdsDevAddr, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ApplicationPackageAssociation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * GetAssociation returns the association registered on the FPort of the end device.
    * 
    * @param idsEndDeviceIdsApplicationIdsApplicationId  
    * @param idsEndDeviceIdsDeviceId  
    * @param idsFPort  
    * @param idsEndDeviceIdsDevEui The LoRaWAN DevEUI. (optional)
    * @param idsEndDeviceIdsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param idsEndDeviceIdsDevAddr The LoRaWAN DevAddr. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3ApplicationPackageAssociation?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryGetAssociationWithHttpInfo(idsEndDeviceIdsApplicationIdsApplicationId: kotlin.String, idsEndDeviceIdsDeviceId: kotlin.String, idsFPort: kotlin.Long, idsEndDeviceIdsDevEui: kotlin.ByteArray?, idsEndDeviceIdsJoinEui: kotlin.ByteArray?, idsEndDeviceIdsDevAddr: kotlin.ByteArray?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3ApplicationPackageAssociation?> {
        val localVariableConfig = applicationPackageRegistryGetAssociationRequestConfig(idsEndDeviceIdsApplicationIdsApplicationId = idsEndDeviceIdsApplicationIdsApplicationId, idsEndDeviceIdsDeviceId = idsEndDeviceIdsDeviceId, idsFPort = idsFPort, idsEndDeviceIdsDevEui = idsEndDeviceIdsDevEui, idsEndDeviceIdsJoinEui = idsEndDeviceIdsJoinEui, idsEndDeviceIdsDevAddr = idsEndDeviceIdsDevAddr, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3ApplicationPackageAssociation>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistryGetAssociation
    *
    * @param idsEndDeviceIdsApplicationIdsApplicationId  
    * @param idsEndDeviceIdsDeviceId  
    * @param idsFPort  
    * @param idsEndDeviceIdsDevEui The LoRaWAN DevEUI. (optional)
    * @param idsEndDeviceIdsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param idsEndDeviceIdsDevAddr The LoRaWAN DevAddr. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun applicationPackageRegistryGetAssociationRequestConfig(idsEndDeviceIdsApplicationIdsApplicationId: kotlin.String, idsEndDeviceIdsDeviceId: kotlin.String, idsFPort: kotlin.Long, idsEndDeviceIdsDevEui: kotlin.ByteArray?, idsEndDeviceIdsJoinEui: kotlin.ByteArray?, idsEndDeviceIdsDevAddr: kotlin.ByteArray?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (idsEndDeviceIdsDevEui != null) {
                    put("ids.end_device_ids.dev_eui", listOf(idsEndDeviceIdsDevEui.toString()))
                }
                if (idsEndDeviceIdsJoinEui != null) {
                    put("ids.end_device_ids.join_eui", listOf(idsEndDeviceIdsJoinEui.toString()))
                }
                if (idsEndDeviceIdsDevAddr != null) {
                    put("ids.end_device_ids.dev_addr", listOf(idsEndDeviceIdsDevAddr.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/as/applications/{ids.end_device_ids.application_ids.application_id}/devices/{ids.end_device_ids.device_id}/packages/associations/{ids.f_port}".replace("{"+"ids.end_device_ids.application_ids.application_id"+"}", "$idsEndDeviceIdsApplicationIdsApplicationId").replace("{"+"ids.end_device_ids.device_id"+"}", "$idsEndDeviceIdsDeviceId").replace("{"+"ids.f_port"+"}", "$idsFPort"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * GetDefaultAssociation returns the default association registered on the FPort of the application.
    * 
    * @param idsApplicationIdsApplicationId  
    * @param idsFPort  
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3ApplicationPackageDefaultAssociation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryGetDefaultAssociation(idsApplicationIdsApplicationId: kotlin.String, idsFPort: kotlin.Long, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3ApplicationPackageDefaultAssociation {
        val localVarResponse = applicationPackageRegistryGetDefaultAssociationWithHttpInfo(idsApplicationIdsApplicationId = idsApplicationIdsApplicationId, idsFPort = idsFPort, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ApplicationPackageDefaultAssociation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * GetDefaultAssociation returns the default association registered on the FPort of the application.
    * 
    * @param idsApplicationIdsApplicationId  
    * @param idsFPort  
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3ApplicationPackageDefaultAssociation?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryGetDefaultAssociationWithHttpInfo(idsApplicationIdsApplicationId: kotlin.String, idsFPort: kotlin.Long, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3ApplicationPackageDefaultAssociation?> {
        val localVariableConfig = applicationPackageRegistryGetDefaultAssociationRequestConfig(idsApplicationIdsApplicationId = idsApplicationIdsApplicationId, idsFPort = idsFPort, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3ApplicationPackageDefaultAssociation>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistryGetDefaultAssociation
    *
    * @param idsApplicationIdsApplicationId  
    * @param idsFPort  
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun applicationPackageRegistryGetDefaultAssociationRequestConfig(idsApplicationIdsApplicationId: kotlin.String, idsFPort: kotlin.Long, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/as/applications/{ids.application_ids.application_id}/packages/associations/{ids.f_port}".replace("{"+"ids.application_ids.application_id"+"}", "$idsApplicationIdsApplicationId").replace("{"+"ids.f_port"+"}", "$idsFPort"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List returns the available packages for the end device.
    * 
    * @param applicationIdsApplicationId  
    * @param deviceId  
    * @param devEui The LoRaWAN DevEUI. (optional)
    * @param joinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param devAddr The LoRaWAN DevAddr. (optional)
    * @return V3ApplicationPackages
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryList(applicationIdsApplicationId: kotlin.String, deviceId: kotlin.String, devEui: kotlin.ByteArray?, joinEui: kotlin.ByteArray?, devAddr: kotlin.ByteArray?) : V3ApplicationPackages {
        val localVarResponse = applicationPackageRegistryListWithHttpInfo(applicationIdsApplicationId = applicationIdsApplicationId, deviceId = deviceId, devEui = devEui, joinEui = joinEui, devAddr = devAddr)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ApplicationPackages
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * List returns the available packages for the end device.
    * 
    * @param applicationIdsApplicationId  
    * @param deviceId  
    * @param devEui The LoRaWAN DevEUI. (optional)
    * @param joinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param devAddr The LoRaWAN DevAddr. (optional)
    * @return ApiInfrastructureResponse<V3ApplicationPackages?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryListWithHttpInfo(applicationIdsApplicationId: kotlin.String, deviceId: kotlin.String, devEui: kotlin.ByteArray?, joinEui: kotlin.ByteArray?, devAddr: kotlin.ByteArray?) : ApiInfrastructureResponse<V3ApplicationPackages?> {
        val localVariableConfig = applicationPackageRegistryListRequestConfig(applicationIdsApplicationId = applicationIdsApplicationId, deviceId = deviceId, devEui = devEui, joinEui = joinEui, devAddr = devAddr)

        return request<Unit, V3ApplicationPackages>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistryList
    *
    * @param applicationIdsApplicationId  
    * @param deviceId  
    * @param devEui The LoRaWAN DevEUI. (optional)
    * @param joinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param devAddr The LoRaWAN DevAddr. (optional)
    * @return RequestConfig
    */
    fun applicationPackageRegistryListRequestConfig(applicationIdsApplicationId: kotlin.String, deviceId: kotlin.String, devEui: kotlin.ByteArray?, joinEui: kotlin.ByteArray?, devAddr: kotlin.ByteArray?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (devEui != null) {
                    put("dev_eui", listOf(devEui.toString()))
                }
                if (joinEui != null) {
                    put("join_eui", listOf(joinEui.toString()))
                }
                if (devAddr != null) {
                    put("dev_addr", listOf(devAddr.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/as/applications/{application_ids.application_id}/devices/{device_id}/packages".replace("{"+"application_ids.application_id"+"}", "$applicationIdsApplicationId").replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * ListAssociations returns all of the associations of the end device.
    * 
    * @param idsApplicationIdsApplicationId  
    * @param idsDeviceId  
    * @param idsDevEui The LoRaWAN DevEUI. (optional)
    * @param idsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param idsDevAddr The LoRaWAN DevAddr. (optional)
    * @param limit Limit the number of results per page. Each page is ordered by the FPort. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3ApplicationPackageAssociations
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryListAssociations(idsApplicationIdsApplicationId: kotlin.String, idsDeviceId: kotlin.String, idsDevEui: kotlin.ByteArray?, idsJoinEui: kotlin.ByteArray?, idsDevAddr: kotlin.ByteArray?, limit: kotlin.Long?, page: kotlin.Long?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3ApplicationPackageAssociations {
        val localVarResponse = applicationPackageRegistryListAssociationsWithHttpInfo(idsApplicationIdsApplicationId = idsApplicationIdsApplicationId, idsDeviceId = idsDeviceId, idsDevEui = idsDevEui, idsJoinEui = idsJoinEui, idsDevAddr = idsDevAddr, limit = limit, page = page, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ApplicationPackageAssociations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * ListAssociations returns all of the associations of the end device.
    * 
    * @param idsApplicationIdsApplicationId  
    * @param idsDeviceId  
    * @param idsDevEui The LoRaWAN DevEUI. (optional)
    * @param idsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param idsDevAddr The LoRaWAN DevAddr. (optional)
    * @param limit Limit the number of results per page. Each page is ordered by the FPort. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3ApplicationPackageAssociations?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryListAssociationsWithHttpInfo(idsApplicationIdsApplicationId: kotlin.String, idsDeviceId: kotlin.String, idsDevEui: kotlin.ByteArray?, idsJoinEui: kotlin.ByteArray?, idsDevAddr: kotlin.ByteArray?, limit: kotlin.Long?, page: kotlin.Long?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3ApplicationPackageAssociations?> {
        val localVariableConfig = applicationPackageRegistryListAssociationsRequestConfig(idsApplicationIdsApplicationId = idsApplicationIdsApplicationId, idsDeviceId = idsDeviceId, idsDevEui = idsDevEui, idsJoinEui = idsJoinEui, idsDevAddr = idsDevAddr, limit = limit, page = page, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3ApplicationPackageAssociations>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistryListAssociations
    *
    * @param idsApplicationIdsApplicationId  
    * @param idsDeviceId  
    * @param idsDevEui The LoRaWAN DevEUI. (optional)
    * @param idsJoinEui The LoRaWAN JoinEUI (AppEUI until LoRaWAN 1.0.3 end devices). (optional)
    * @param idsDevAddr The LoRaWAN DevAddr. (optional)
    * @param limit Limit the number of results per page. Each page is ordered by the FPort. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun applicationPackageRegistryListAssociationsRequestConfig(idsApplicationIdsApplicationId: kotlin.String, idsDeviceId: kotlin.String, idsDevEui: kotlin.ByteArray?, idsJoinEui: kotlin.ByteArray?, idsDevAddr: kotlin.ByteArray?, limit: kotlin.Long?, page: kotlin.Long?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (idsDevEui != null) {
                    put("ids.dev_eui", listOf(idsDevEui.toString()))
                }
                if (idsJoinEui != null) {
                    put("ids.join_eui", listOf(idsJoinEui.toString()))
                }
                if (idsDevAddr != null) {
                    put("ids.dev_addr", listOf(idsDevAddr.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/as/applications/{ids.application_ids.application_id}/devices/{ids.device_id}/packages/associations".replace("{"+"ids.application_ids.application_id"+"}", "$idsApplicationIdsApplicationId").replace("{"+"ids.device_id"+"}", "$idsDeviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * ListDefaultAssociations returns all of the default associations of the application.
    * 
    * @param idsApplicationId  
    * @param limit Limit the number of results per page. Each page is ordered by the FPort. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return V3ApplicationPackageDefaultAssociations
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryListDefaultAssociations(idsApplicationId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : V3ApplicationPackageDefaultAssociations {
        val localVarResponse = applicationPackageRegistryListDefaultAssociationsWithHttpInfo(idsApplicationId = idsApplicationId, limit = limit, page = page, fieldMaskPaths = fieldMaskPaths)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ApplicationPackageDefaultAssociations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * ListDefaultAssociations returns all of the default associations of the application.
    * 
    * @param idsApplicationId  
    * @param limit Limit the number of results per page. Each page is ordered by the FPort. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return ApiInfrastructureResponse<V3ApplicationPackageDefaultAssociations?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistryListDefaultAssociationsWithHttpInfo(idsApplicationId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : ApiInfrastructureResponse<V3ApplicationPackageDefaultAssociations?> {
        val localVariableConfig = applicationPackageRegistryListDefaultAssociationsRequestConfig(idsApplicationId = idsApplicationId, limit = limit, page = page, fieldMaskPaths = fieldMaskPaths)

        return request<Unit, V3ApplicationPackageDefaultAssociations>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistryListDefaultAssociations
    *
    * @param idsApplicationId  
    * @param limit Limit the number of results per page. Each page is ordered by the FPort. (optional)
    * @param page Page number for pagination. 0 is interpreted as 1. (optional)
    * @param fieldMaskPaths The set of field mask paths. (optional)
    * @return RequestConfig
    */
    fun applicationPackageRegistryListDefaultAssociationsRequestConfig(idsApplicationId: kotlin.String, limit: kotlin.Long?, page: kotlin.Long?, fieldMaskPaths: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (fieldMaskPaths != null) {
                    put("field_mask.paths", toMultiValue(fieldMaskPaths.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/as/applications/{ids.application_id}/packages/associations".replace("{"+"ids.application_id"+"}", "$idsApplicationId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * SetAssociation updates or creates the association on the FPort of the end device.
    * 
    * @param associationIdsEndDeviceIdsApplicationIdsApplicationId  
    * @param associationIdsEndDeviceIdsDeviceId  
    * @param associationIdsFPort  
    * @param body  
    * @return V3ApplicationPackageAssociation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistrySetAssociation(associationIdsEndDeviceIdsApplicationIdsApplicationId: kotlin.String, associationIdsEndDeviceIdsDeviceId: kotlin.String, associationIdsFPort: kotlin.Long, body: V3SetApplicationPackageAssociationRequest) : V3ApplicationPackageAssociation {
        val localVarResponse = applicationPackageRegistrySetAssociationWithHttpInfo(associationIdsEndDeviceIdsApplicationIdsApplicationId = associationIdsEndDeviceIdsApplicationIdsApplicationId, associationIdsEndDeviceIdsDeviceId = associationIdsEndDeviceIdsDeviceId, associationIdsFPort = associationIdsFPort, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ApplicationPackageAssociation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * SetAssociation updates or creates the association on the FPort of the end device.
    * 
    * @param associationIdsEndDeviceIdsApplicationIdsApplicationId  
    * @param associationIdsEndDeviceIdsDeviceId  
    * @param associationIdsFPort  
    * @param body  
    * @return ApiInfrastructureResponse<V3ApplicationPackageAssociation?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistrySetAssociationWithHttpInfo(associationIdsEndDeviceIdsApplicationIdsApplicationId: kotlin.String, associationIdsEndDeviceIdsDeviceId: kotlin.String, associationIdsFPort: kotlin.Long, body: V3SetApplicationPackageAssociationRequest) : ApiInfrastructureResponse<V3ApplicationPackageAssociation?> {
        val localVariableConfig = applicationPackageRegistrySetAssociationRequestConfig(associationIdsEndDeviceIdsApplicationIdsApplicationId = associationIdsEndDeviceIdsApplicationIdsApplicationId, associationIdsEndDeviceIdsDeviceId = associationIdsEndDeviceIdsDeviceId, associationIdsFPort = associationIdsFPort, body = body)

        return request<V3SetApplicationPackageAssociationRequest, V3ApplicationPackageAssociation>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistrySetAssociation
    *
    * @param associationIdsEndDeviceIdsApplicationIdsApplicationId  
    * @param associationIdsEndDeviceIdsDeviceId  
    * @param associationIdsFPort  
    * @param body  
    * @return RequestConfig
    */
    fun applicationPackageRegistrySetAssociationRequestConfig(associationIdsEndDeviceIdsApplicationIdsApplicationId: kotlin.String, associationIdsEndDeviceIdsDeviceId: kotlin.String, associationIdsFPort: kotlin.Long, body: V3SetApplicationPackageAssociationRequest) : RequestConfig<V3SetApplicationPackageAssociationRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/as/applications/{association.ids.end_device_ids.application_ids.application_id}/devices/{association.ids.end_device_ids.device_id}/packages/associations/{association.ids.f_port}".replace("{"+"association.ids.end_device_ids.application_ids.application_id"+"}", "$associationIdsEndDeviceIdsApplicationIdsApplicationId").replace("{"+"association.ids.end_device_ids.device_id"+"}", "$associationIdsEndDeviceIdsDeviceId").replace("{"+"association.ids.f_port"+"}", "$associationIdsFPort"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * SetDefaultAssociation updates or creates the default association on the FPort of the application.
    * 
    * @param defaultIdsApplicationIdsApplicationId  
    * @param defaultIdsFPort  
    * @param body  
    * @return V3ApplicationPackageDefaultAssociation
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistrySetDefaultAssociation(defaultIdsApplicationIdsApplicationId: kotlin.String, defaultIdsFPort: kotlin.Long, body: V3SetApplicationPackageDefaultAssociationRequest) : V3ApplicationPackageDefaultAssociation {
        val localVarResponse = applicationPackageRegistrySetDefaultAssociationWithHttpInfo(defaultIdsApplicationIdsApplicationId = defaultIdsApplicationIdsApplicationId, defaultIdsFPort = defaultIdsFPort, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as V3ApplicationPackageDefaultAssociation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * SetDefaultAssociation updates or creates the default association on the FPort of the application.
    * 
    * @param defaultIdsApplicationIdsApplicationId  
    * @param defaultIdsFPort  
    * @param body  
    * @return ApiInfrastructureResponse<V3ApplicationPackageDefaultAssociation?>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applicationPackageRegistrySetDefaultAssociationWithHttpInfo(defaultIdsApplicationIdsApplicationId: kotlin.String, defaultIdsFPort: kotlin.Long, body: V3SetApplicationPackageDefaultAssociationRequest) : ApiInfrastructureResponse<V3ApplicationPackageDefaultAssociation?> {
        val localVariableConfig = applicationPackageRegistrySetDefaultAssociationRequestConfig(defaultIdsApplicationIdsApplicationId = defaultIdsApplicationIdsApplicationId, defaultIdsFPort = defaultIdsFPort, body = body)

        return request<V3SetApplicationPackageDefaultAssociationRequest, V3ApplicationPackageDefaultAssociation>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation applicationPackageRegistrySetDefaultAssociation
    *
    * @param defaultIdsApplicationIdsApplicationId  
    * @param defaultIdsFPort  
    * @param body  
    * @return RequestConfig
    */
    fun applicationPackageRegistrySetDefaultAssociationRequestConfig(defaultIdsApplicationIdsApplicationId: kotlin.String, defaultIdsFPort: kotlin.Long, body: V3SetApplicationPackageDefaultAssociationRequest) : RequestConfig<V3SetApplicationPackageDefaultAssociationRequest> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/as/applications/{default.ids.application_ids.application_id}/packages/associations/{default.ids.f_port}".replace("{"+"default.ids.application_ids.application_id"+"}", "$defaultIdsApplicationIdsApplicationId").replace("{"+"default.ids.f_port"+"}", "$defaultIdsFPort"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
